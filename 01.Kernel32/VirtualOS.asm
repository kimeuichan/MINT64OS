[ORG 0x00] 						; 코드의 시작 어드레스를 0x00으로 설정
[BITS 16] 						; 이하의 코드는 16비트 코드로 설정

SECTION .text 					; text 섹션(세그먼트)을 정의


jmp 0x1000:START 				; cs 세그먼트 레지스터에 0x1000을 복사하면서, START 테이블로 이동

SECTORCOUNT: dw 0x0000 			; 현재 실행 중인 섹터 번호를 저장
TOTALSECTORCOUNT: equ 1024 		; 가상 OS의 총 섹터 수
								; 최대 1152 섹터(0x90000byte)까지 가능

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 코드 영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;						

START:
	mov ax, cs 					; cs 세그먼트 레지스터의 값을 ax 레지스터에 설정
	mov ds, ax 					; ax 레지스트의 값을 ds 세그먼트 레지스터에 설정
	mov ax, 0xb800 				; 비디오 메모리 어드레스인 0xb8000을 세그먼트 레지스터 값으로 변한	
	mov es, ax 					; es 세그먼트 레지스터에 설정

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; 각 섹터 별로 코드를 실행
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	%assign i 	0 				; i 를 0으로 초기화
	%rep TOTALSECTORCOUNT 		; TOTALSECTORCOUNT 에 저장된 값만큼 아래 코드를 반복
		%assign i 	i + 1 		; i 를 1 증가

		; 현재 실행 중인 코드가 포함된 섹터의 위치를 화면 좌표로 변환
		mov ax,2 				; 한 문자를 나타내는 바이트 수 (2)를
 								; ax 레지스터에 설정
		mul word[SECTORCOUNT] 	; ax 레지스터와 섹터 수를 곱함
		mov si,ax 				; 곱한 결과를 si 레지스터에 설정

		; 계산된 결과를 비디오 메모리에 오프셋으로 삼아 세번째 라인부터 화면에 0을 출력
		mov byte [es:si+ (160 * 2) ],'0' + (i % 10)
		add word [SECTORCOUNT],1 	; 섹터 수를 1증가

		; 마지막 섹터이면 더 수행할 섹터가 없으므로 무한 루프 수행, 그렇지 않으면
		; 다음 섹터로 이동해서 코드 수행
		%if i == TOTALSECTORCOUNT 			; i 가 TOTALSECTORCOUNT와 같다면, 즉 마지막 섹터라면
			jmp $ 							; 무한 루프 실행
		%else 								; 마지막 섹터가 아니라면
			jmp (0x1000 + i * 0x20 ): 0x0000 	; 다음 섹터 오프셋으로 이동
		%endif 								; if 문의 끝

		times (512 - ( $ - $$ ) % 512) db 0x00
	%endrep 					; 반복문의 끝
