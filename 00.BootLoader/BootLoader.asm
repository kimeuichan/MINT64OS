[ORG 0x00]					; 코드의 시작 어드레스를 0x00으로 설정
[BITS 16]					; 이하의 코드는 16비트로 설정

SECTION .text
jmp 0x07c0:START 			; CS 세그먼트 레지스터에 0x07c0을 복사하면서, START 레이블로 이동

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				MINT64 OS에 관련된 환경 설정 값
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TOTALSECTORCOUNT: dw 1024	; 부트 로더를 제외한 MINT64 OS 이미지의 크기
							; 최대 1152 섹터(0x90000byte)까지 가능


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				코드 영역	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
START:
	mov ax, 0x07c0 			; 부트 로더의 시작 어드레스를 (0x07c00)를 세그먼트 레지스터 값으로 변환
	mov ds, ax				; DS 세그먼트 레지스터에 설정
	mov ax, 0xB800 			; 비디오 메모리의 시작 어드레스(0xb800)를 세그먼트 레지스터 값으로 변환
	mov es, ax 				; ES 세그먼트 레지스터에 설정

	; 스택을 0x0000:0000~0x0000:FFFF 영역에 64KB 크기로 생성
	mov ax, 0x0000 			; 스택 세그먼트의 시작 어드레스(0x0000)를 세그먼트 레지스터 값으로 변환
	mov ss, ax				; SS 세그먼트 레지스터에 설정
	mov sp, 0xfffe			; SP 레지스터의 어드레스를 0xFFFE로 설정
	mov bp, 0xfffe 			; BP 레지스터의 어드레스를 0xfffe로 설정

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				화면을 모두 지우고, 속성값을 녹색으로 설정	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	mov si, 0 				; si 레지스터를 초기화



.SCREENCLEARLOOP:
	mov byte[es:si], 0 		; 비디오 메모리의 문자가 위치하는 어드레스에 0을 복사하여 문자를 삭제
	mov byte[es:si+1], 0x0a 	; 비디오 메모리의 속성이 위치하는 어드레스에 0x0a(검은 바탕 밝은 녹색) 복사

	add si,2 				; 문자와 속성을 설정했으므로 다음 위치로 이동

	cmp si, 80*25*2			; 화면의 전체 크기는 80 문자 * 25 라인
							; 출력한 문자의 수를 의미하는 si 레지스터와 비교
	jl .SCREENCLEARLOOP 	; si 레지스터가 80 * 25 * 2 보다 작다면 아직 지우지 못한 영역이므로 .SCREENCLEARLOOP로 이동

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				화면 상단에 시작 메시지 출력
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	push MESSAGE1 			; 출력할 메시지의 어드레스를 스택에 삽입
	push 0 					; 화면 y 좌표를 스택에 삽입
	push 0 					; 화면 x 좌표를 스택에 삽입
	call PRINTMESSAGE 		; PRINTMESSAGE 함수 호출
	add sp,6 				; 삽입한 파라미터 제거

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				OS 이미지를 로딩한다는 메시지 출력
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	push IMAGELOADINGMESSAGE	; 출력할 메시지의 어드레스를 스택에 삽입
	push 1 						; 화면 y 좌표를 스택에 삽입
	push 0 						; 화면 x 좌표를 스택에 삽입
	call PRINTMESSAGE 			; PRINTMESSAGE 함수 호출
	add sp,6 					; 삽입한 파라미터 제거

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				디스크에서 OS 이미지를 로딩
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				디스크를 읽기 전에 먼저 리셋
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

RESETDISK:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				BIOS Reset Function 호출
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 서비스 번호 0, 드라이브 번호(0==Floppy)

	mov ax, 0
	mov dl, 0
	int 0x13
	;에러가 발생하면 에러 처리로 이동
	jc HANDLEDISKERROR

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				디스크에서 섹터를 읽음
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 디스크의 내용을 메모리로 복사할 어드레스(ES:BX)를 0x1000으로 설정
	mov si, 0x1000 				; OS 이미지를 복사할 어드레스(0x10000)를
	mov es, si 					; 세그먼트 레지스터 값으로 변환
	mov bx, 0x0000 				; BX레지스터에 0x0000을 설정하여 복사할
								; 어드레스를 0x1000:000(0x10000)으로 최종 설정

	mov di, word[TOTALSECTORCOUNT] ; 복사할 OS이미지의 섹터 수를 DI 레지스터에 설정

READDATA:
	; 모든 섹터를 다 읽었는지 확인
	cmp di, 0
	je READEND					; 복사할 섹터 수가 0이라면 다 복사 했으므로 READEND로 이동
	sub di, 0x1 				; 복사할 섹터 수를 1 감소

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				BIOS Read Function 호출
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	mov ah, 0x02 				; BIOS 서비스 번호 2(Read Sector)
	mov al, 0x1 				; 읽을 섹터 수는 1
	mov ch, byte[TRACKNUMBER]	; 읽을 트랙 번호 설정
	mov cl, byte[SECTORNUMBER]	; 읽을 섹터 번호 설정
	mov dh, byte[HEADNUMBER]	; 읽을 헤드 번호 설정
	mov dl, 0x00 				; 읽을 드라이버 번호(0==Floppy) 설정
	int 0x13
	jc HANDLEDISKERROR 			; 에러가 발생했다면 HANDLEDISKERROR로 이동

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				복사할 어드레스와 트랙, 헤드, 섹터 어드레스 계산
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	add si, 0x0020 				; 512(0x200)바이트 만큼 읽었으므로, 이를 세그먼트 레지스터 값으로 변환
	mov es, si 					; ES 세그먼트 레지스터에 더해서 어드레스를 한 섹터 만큼 증가

; 한 섹터를 읽었으므로 섹터 번호를 증가시키고 마지막 섹터(18)까지 읽었는지 판단
; 마지막 섹터가 아니면 섹터 읽기로 이동해서 다시 섹터 읽기 수행

	mov al, byte[SECTORNUMBER] 	; 섹터 번호를 AL 레지스터에 설정
	add al, 0x01 				; 섹터 번호를 1 증가
	mov byte [SECTORNUMBER], al ; 증가시킨 섹터 번호를 SECTORNUMBER에 다시 설정
	cmp al, 19 					; 증가시킨 섹터 번호를 19와 비교
	jl READDATA

	xor byte[HEADNUMBER], 0x01 	;헤드 번호를 0x01 과 XOR 하여 토글(0->1), (1->0)
	mov byte[SECTORNUMBER], 0x01 ; 섹터 번호를 다시 1로 설정

	cmp byte[HEADNUMBER], 0x00 	; 헤드 번호를 0x00과 비교
	jne READDATA 				; 헤드 번호가 0이 아니면 READDATA로 이동

	add byte[TRACKNUMBER], 0x01 	;트랙 번호를 1 증가
	jmp READDATA 					; READDATA로 이동

READEND:

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				OS 이미지가 완료되었다는 메세지 출력
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	push LOADINGCOMPLETEMESSAGE ; 출력할 메세지의 어드레스를 스택에 삽입
	push 1
	push 20
	call PRINTMESSAGE
	add sp, 6

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				로딩한 가상 OS 이미지 실행
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	jmp 0x1000:0x0000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				함수 코드 영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				디스크 에러를 처리하는 함수
HANDLEDISKERROR:
	push DISKERRORMESSAGE 		; 에러 문자열의 어드레스를 스택에 삽입
	push 1
	push 20
	call PRINTMESSAGE

	jmp $ 						; 현재 위치에서 무한 루프 수행

; 메시지를 출력하는 함수
; PARAM : x,y 문자열

PRINTMESSAGE:
	push bp 					; bp 를 스택에 삽입
	mov bp,sp 					; bp 에 sp 값 설정

	push es 					; es 세그먼트부터 dx 레지스터까지 스택에 삽입
	push si
	push di
	push ax
	push cx
	push dx

	; ES 세그먼트 레지스터에 비디오 모드 어드레스 설정

	mov ax, 0xB800
	mov es, ax 					; es 에 비디오 메모리 시작 어드레스 설정

	mov ax, word[bp+6]
	mov si, 160
	mul si
	mov di, ax

	mov ax, word[bp+4]
	mov si, 2
	mul si
	add di, ax

	mov si, word[bp+8]			;출력할 문자열 어드레스(파라미터3)

.MESSAGELOOP:
	mov cl, byte[si]	;si 레지스터가 가리키는 문자열 위치에서 한문자를 cl 레지스터에 복사

	cmp cl, 0 					;복사된 문자열이 0 인지 아닌지 비교
	je .MESSAGEEND 				;0이면 루프 종료

	mov byte[es:di], cl 		;0이 아니면 문자를 채움

	add si, 1
	add di, 2

	jmp .MESSAGELOOP

.MESSAGEEND:
	pop dx 			 			; 함수에서 사용이 끝난 dx 레지스터부터 es 레지스터까지를 스택에
	pop cx 						; 삽입된 값을 이용해서 복원
	pop ax 						; 스택은 가장 마지막에 들어간 데이터가 가장 먼저 나오는
	pop di 						; 자료구조(LIFO)이므로 삽입의 역순으로
	pop si 						; 제거 해야함
	pop es
	pop bp
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				데이터 영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


MESSAGE1: db 'MINT64 OS Boot Loader Start~!!!', 0
DISKERRORMESSAGE: db 'DiSK ERROR~!!', 0
IMAGELOADINGMESSAGE: db 'OS Image Loading...',0
LOADINGCOMPLETEMESSAGE: db 'Complete~!!!',0

SECTORNUMBER: db 0x02 				; OS 이미지가 시작하는 섹터 번호를 저장하는 영역
HEADNUMBER: db 0x00 				; OS 이미지가 시작하는 헤드 번호를 저장하는 영역
TRACKNUMBER: db 0x00 				; OS 이미지가 시작하는 트랙 번호를 저장하는 영역

times 510 - ($-$$) db 0x00

db 0x55
db 0xAA